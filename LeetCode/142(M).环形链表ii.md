题目链接: https://leetcode.cn/leetbook/read/linked-list/jjhf6/


## 方法一：缓存
一般很直观的就能想到 `缓存` ,遍历链表的时候将节点缓存，每次都判断当前节点是否在缓存中出现。

这个方法额外消耗空间，并且如果链表很长一环又在很远的地方，那时间复杂度也非常高。

```JavaScript
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var detectCycle = function (head) {
  let hash = new Map()
  let curNode = head
  while (curNode) {
    if (hash.has(curNode)) {
      return hash.get(curNode)
    }
    hash.set(curNode, curNode)
    curNode = curNode.next
  }

  return null
};
```

## 方法二：双指针
```JavaScript
/**
 * @param {ListNode} head
 * @return {boolean}
 */
var hasCycle = function(head) {
  let slow = head
  let fast = head
  // 慢指针每次前进一步，快指针每次前进两步
  while (fast && fast.next) {
    slow = slow.next
    fast = fast.next.next

    if (slow === fast) {
      return true
    }
  }

  return false
};
```
