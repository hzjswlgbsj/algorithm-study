题目链接: https://leetcode.cn/problems/find-mode-in-binary-search-tree/

## 思路
- 直接遍历所有节点，保存每个值的出现次数，取次数最大的
- 以次val为key，次数为值缓存
- 然后遍历缓存对象找到次数最大


## 第一版
```JavaScript
遍历一遍统计数值和次数，然后从统计表里面去找众数
var findMode = function (root) {
  let res = []
  let map = {}

  if (!root) {
    return
  }

  function traverse(root) {
    if (!root) {
      return
    }

    if (typeof map[root.val] !== 'undefined') {
      map[root.val]++
    } else {
      map[root.val] = 1
    }

    traverse(root.left)
    traverse(root.right)
  }

  traverse(root)
  let curMax = 0
  for (const [key, value] of Object.entries(map)) {
    if (curMax < value) {
      curMax = value
      res = [key]
    } else if (curMax === value) {
      res.push(key)
    }
  }

  return res
};
```

## 第二版
方案一是最容易想出来的方法，但是没有利用题目给定的一个条件：这颗二叉树是二叉搜索树，在排序方面应该是可以优化的。

- 由于是二叉搜索树，所以数值相等的节点肯定是连续出现的
  - 定义一个lastCount来记录前一个最大次数，定义一个curCount记录当前的最大次数，定义一个lastValue来记录上一次的值
  - 如果当前节点的值与上次相同就curCount++，否则就对比curCount与lastCount
    - curCount === lastCount
  
```JavaScript
var findMode = function (root) {
  
};
```
