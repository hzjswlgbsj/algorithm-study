题目链接: https://leetcode.cn/problems/unique-binary-search-trees/

## 题目大意
题干：给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

这题的意思是要排列组合出有多少种排法能满足是一颗二叉搜索树，换言之就是：二叉搜索树中截取n个连续节点，有多少种截取方式
## 思路1
首先要知道的是二叉搜索树按序遍历那肯定是中序遍历，其次造成不同情况的因素就是左右子树的组合方式

假设给算法输入 n = 5，也就是说用 {1,2,3,4,5} 这些数字去构造 BST。

如果固定 3 作为根节点，左子树节点就是 {1,2} 的组合，右子树就是 {4,5} 的组合：

那么 {1,2} 和 {4,5} 的组合有多少种呢？left * right，这里就是 2 * 2。为什么组合的数量等于 左子树的数量 与 右子树的树的数量 相乘呢？下面引用 LeetCode 上的一个评论：

> 你可以这么想，左子树和右子树中的元素肯定不重叠，因此决定左子树和右子树是相互独立的过程，可以分步考虑，因此可以采取分步计数原理，即乘法原理。分步计数原理（乘法原理）应该是高中讲计数原理或者古典概率类型的时候学到的，也有一部分人在小学奥数的时候就学了，与之相似的概念是分类计数原理（加法原理）。

> 顺便简单说一下分步计数原理和分类计数原理的内容： 分类计数原理（加法原理）：完成一件事，发现有n种不同的 决 定 性 方 式，即每种不同的方式都会直接将这件事解决，那么如果第i种方式有k_i种具体的解决方法，那么完成这件事的总方法数就是对所有的k_i求和； 分步计数原理（乘法原理）：完成一件事，发现可以将这件事分成n个小问题来 顺 序 解 决（或者这些小问题之间彼此独立，且事情的最终结果依赖于所有的这n个小问题的结果），那么如果第i个小问题有k_i种解决方法，则完成这件事的总方法数就是对所有的k_i求积。

另外，这题存在重叠子问题，可以通过备忘录的方式消除冗余计算。

## 实现
```JavaScript
/**
 * @param {number} n
 * @return {number}
 */
var numTrees = function (n) {
  let memo = []
  return count(1, n)

  function count(start, end) {
    //空二叉树也是一棵搜索二叉树
    if (start > end) {
      return 1
    }

    //因为二叉搜索树的种类只与节点个数有关，那么建立备忘录，防止重复计算
    if (!memo[start]) {
      memo[start] = []
    }
    if (memo[start][end]) {
      return memo[start][end]
    }

    let res = 0

    for (let i = start; i <= end; i++) {
      //以i为根节点时左，右子树的个数
      let left = count(start, i -  1)      
      let right = count(i + 1, end)    
      
      res += left * right
    }

    memo[start][end] = res
    return res
  }
};
```

## 思路2
