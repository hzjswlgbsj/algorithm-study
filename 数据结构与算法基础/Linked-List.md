# 链表介绍
与数组相似，链表也是一种 `线性` 数据结构。

```
|---|---|    |---|---|    |---|---|
| 4 | •-|--->| 7 | •-|--->| 9 | •-|---> null        
|---|---|    |---|---|    |---|---| 
```

正如你所看到的，链表中的每个元素实际上是一个单独的对象，而所有对象都通过每个元素中的引用字段链接在一起。

链表结构有很多种，它们分别是：单链表、双向链表和循环链表。我们首先来看最简单、最常用的单链表。

# 单链表
单链表中的每个结点不仅包含值，还包含链接到下一个结点的引用字段。通过这种方式，单链表将所有结点按顺序组织起来。

一般单链表可以标识为如下结构
```typescript
interface SinglyListNode {
  val: numbar;
  next: SinglyListNode;
  SinglyListNode: (x: number) => { val = x }
}
```

在大多数情况下，我们将使用头结点(第一个结点)来表示整个列表。

与数组不同，我们无法在常量时间内访问单链表中的随机元素。 如果我们想要获得第 i 个元素，我们必须从头结点逐个遍历。 我们按 `索引` 来 `访问元素` 平均要花费 `O(N)` 时间，其中 `N` 是链表的长度。


## 实现单链表
设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：`val` 和 `next`。`val` 是当前节点的值，`next` 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 `prev` 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。

在链表类中实现这些功能：

- get(index)：获取链表中第 `index` 个节点的值。如果索引无效，则返回 `-1`。
- addAtHead(val)：在链表的第一个元素之前添加一个值为 `val` 的节点。插入后，新节点将成为链表的第一个节点。
- addAtTail(val)：将值为 `val` 的节点追加到链表的最后一个元素。
- addAtIndex(index,val)：在链表中的第 `index` 个节点之前添加值为 `val`  的节点。如果 `index` 等于链表的长度，则该节点将附加到链表的末尾。如果 `index` 大于链表长度，则不会插入节点。如果 `index` 小于 0，则在头部插入节点。
- deleteAtIndex(index)：如果索引 `index` 有效，则删除链表中的第 `index` 个节点。

```javascript
MyLinkedList linkedList = new MyLinkedList();
linkedList.addAtHead(1);
linkedList.addAtTail(3);
linkedList.addAtIndex(1,2);   // 链表变为1-> 2-> 3
linkedList.get(1);            // 返回2
linkedList.deleteAtIndex(1);  // 现在链表是1-> 3
linkedList.get(1);            // 返回3
```



## 单链表添加操作
如果要在单链表的 `prev` 节点后面添加一个新的节点步骤如下：
1. 创建一个新的节点 `cur`
2. 将 `prev` 的 `next` 节点链接到 `cur` 的 `next` 字段上
3. 将 `cur` 节点链接到 `prev` 的 `next` 字段

如果是在头节点添加节点，除了上面的步骤外，还需要将 `cur` 节点设置为链表的 `head` 节点。

## 单链表删除操作

如果想从单链表中删除现有结点 `cur`，可以分两步完成：

1. 找到 `cur` 的上一个结点 `prev` 及其下一个结点 `next` 
2. 接下来链接 `prev` 到 `cur` 的下一个节点 `next` 

在我们的第一步中，我们需要找出 prev 和 next。使用 cur 的参考字段很容易找出 next，但是，我们必须从头结点遍历链表，以找出 prev，它的平均时间是 O(N)，其中 N 是链表的长度。因此，删除结点的时间复杂度将是 O(N)。

空间复杂度为 O(1)，因为我们只需要常量空间来存储指针。

如果要删除头节点的话可以直接将链表的 `head` 指向现在头节点的 `next` 节点

## 用链表实现 LRU 缓存淘汰策略

我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。

1. 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。
2. 如果此数据没有在缓存链表中，又可以分为两种情况：
  - 如果此时缓存未满，则将此结点直接插入到链表的头部；
  - 如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。
